<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Learning tools for Deep Learning</title>

  <!-- use YOUR folder name: css/styles.css -->
  <link rel="stylesheet" href="./css/styles.css" />
  <script src="./js/similarPosts.js"></script>
  <script src="https://d3js.org/d3-hierarchy.v3.min.js"></script>
  <script src="./js/treemap.js"></script>
  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- use YOUR folder name: js/main.js -->
  <script defer type="module" src="./js/main.js"></script>
</head>

<body>
  <a class="skip" href="#content">Skip to content</a>

  <header class="top-title">
    <span class="mastheadTitle">Learning tools for Deep Learning</span>
  </header>

  <main id="content" class="page">
    <!-- HERO -->
    <section class="hero hero--fullscreen">
      <div class="hero-intro">
        <p>UCB Fall 2025 EECS 182/282A Deep Learning Class developed AI/LLM-based learning tools to help them study the material in the class! These are all their submissions.</p>
        <p>Website designed by: Guohao Lv, Shuwei Yang, and Edward Z. Zhang, students in EECS 182/282A.</p>
        <p>Faculty: Prof. Anant Sahai and Prof. Gireeja Ranade</p>
      </div>
    </section>

    <!-- Bottom Nav -->
    <nav class="bottom-nav" aria-label="Secondary">
      <a href="#highlight" class="bottom-nav__link">Examples</a>
      <a href="#submission-type" class="bottom-nav__link">By submission type</a>
      <a href="#concepts" class="bottom-nav__link">By concepts</a>
      <a href="./directory.html" class="bottom-nav__link">See all submissions</a>
    </nav>

    <!-- Categories Carousel Section -->
    <section id = "submission-type" class="categories-section">
      <h2 class="categories-heading">CATEGORIES</h2>
      <div class="categories-section__carousel-wrapper">
        <div id="categoriesCarousel" class="category-carousel" aria-label="Browse by category"></div>
        <div class="carousel-dots" id="carouselDots" role="tablist" aria-label="Carousel pages"></div>
      </div>
    </section>

    <!-- Tag Map Section -->
    <section id = "concepts" class="tag-map-section">
      <h2 class="tag-map-heading">Course Concepts Map</h2>
      <div id="tagMap" class="tag-map-container" aria-label="Tag frequency visualization"></div>
    </section>

    <!-- Featured Examples Carousel -->
    <section id = "highlight" class="featured-examples-section">
      <div class="featured-examples-container">
        <h2 class="featured-examples-heading">Featured Examples</h2>
        <div class="featured-carousel-wrapper">
          <button class="featured-carousel-arrow featured-carousel-arrow--prev" aria-label="Previous slide">
            <span>â€¹</span>
          </button>
          <div class="featured-carousel-viewport">
            <div id="featuredCarousel" class="featured-carousel-track"></div>
          </div>
          <button class="featured-carousel-arrow featured-carousel-arrow--next" aria-label="Next slide">
            <span>â€º</span>
          </button>
        </div>
      </div>
    </section>

    <!-- Dashboard Section -->
    <section id="dashboard-section" class="dashboard-section">
      <div class="dashboard-container">
        <!-- Material-style Tab Bar -->
        <nav class="dashboard-tabs" aria-label="Dashboard navigation">
          <button class="tab-item active" data-view="summary">Summary</button>
          <button class="tab-item" data-view="heatmap">Submission Heatmap</button>
          <button class="tab-item" data-view="timeline">Daily Post Volume</button>
          <button class="tab-item" data-view="categories">Category Breakdown</button>
          <button class="tab-item" data-view="weekly">Weekly Breakdown</button>
        </nav>

        <!-- Main Content Area -->
        <div class="dashboard-main">
          <!-- Left Column: Chart Content -->
          <div class="dashboard-chart-area">
            <!-- Summary View -->
            <div class="dashboard-view active" id="view-summary">
              <h2 class="view-title">Summary</h2>
              <p class="view-description">Overview of submission statistics and key metrics.</p>
              <div class="stats-row">
                <div class="stat-card">
                  <h3>Total Submissions</h3>
                  <div class="value" id="totalCount">-</div>
                </div>
                <div class="stat-card">
                  <h3>Date Range</h3>
                  <div class="value" id="dateRange" style="font-size: 1rem;">-</div>
                </div>
                <div class="stat-card">
                  <h3>Peak Day</h3>
                  <div class="value" id="peakDay" style="font-size: 1rem;">-</div>
                  <div class="change" id="peakCount"></div>
                </div>
                <div class="stat-card">
                  <h3>Avg Per Day</h3>
                  <div class="value" id="avgPerDay">-</div>
                </div>
          </div>
        </div>

            <!-- Heatmap View -->
            <div class="dashboard-view" id="view-heatmap">
              <h2 class="view-title">Submission Heatmap</h2>
              <p class="view-description">Visual representation of submission activity over time, with intensity indicating volume.</p>
              <div class="heatmap-container">
                <div class="month-labels" id="monthLabels"></div>
                <div class="heatmap" id="heatmap"></div>
        </div>
              <div class="heatmap-legend">
                <span>Less</span>
                <div class="heatmap-legend-item" style="background: #161b22;"></div>
                <div class="heatmap-legend-item" style="background: #0e4429;"></div>
                <div class="heatmap-legend-item" style="background: #006d32;"></div>
                <div class="heatmap-legend-item" style="background: #26a641;"></div>
                <div class="heatmap-legend-item" style="background: #39d353;"></div>
                <span>More</span>
      </div>
        </div>

            <!-- Timeline View -->
            <div class="dashboard-view" id="view-timeline">
              <h2 class="view-title">Daily Post Volume</h2>
              <p class="view-description">Bar chart showing the number of submissions per day over the entire period.</p>
              <div class="daily-chart-scroll" id="dailyChartScroll">
                <div class="daily-chart-inner" id="dailyChartInner">
                  <div class="timeline-chart" id="timelineChart"></div>
                  <div class="timeline-labels" id="timelineLabels"></div>
                </div>
              </div>
              <input
                type="range"
                id="dailyChartSlider"
                class="daily-chart-slider"
                min="0"
                max="100"
                value="0"
                aria-label="Scroll Daily Post Volume Chart"
              />
            </div>

            <!-- Categories View -->
            <div class="dashboard-view" id="view-categories">
              <h2 class="view-title">Category Breakdown</h2>
              <p class="view-description">Distribution of submissions across different categories.</p>
              <div class="category-bars" id="categoryBars"></div>
            </div>

            <!-- Weekly View -->
            <div class="dashboard-view" id="view-weekly">
              <h2 class="view-title">Weekly Breakdown</h2>
              <p class="view-description">Submission activity grouped by week, showing trends over time.</p>
              <div class="week-grid" id="weekGrid"></div>
            </div>
          </div>
        </div>
        </div>
    </section>
  </main>

  <!-- READER MODAL -->
  <dialog id="reader" class="reader">
    <form method="dialog" class="reader__close">
      <button class="btn btn--ghost close-icon-btn" aria-label="Close">Ã—</button>
    </form>

    <article class="reader__article">
      <div class="article-detail-layout">
        <!-- Left Column: Metadata (Sticky) -->
        <aside class="article-metadata">
          <h1 id="rTitle" class="article-title"></h1>
          
          <div class="metadata-section">
            <div class="metadata-row">
              <span class="metadata-label">Author</span>
              <span id="rAuthor" class="metadata-value"></span>
            </div>
            <div class="metadata-row">
              <span class="metadata-label">Date</span>
              <span id="rDate" class="metadata-value"></span>
            </div>
            <div class="metadata-row">
              <span class="metadata-label">Category</span>
              <span id="rCategory" class="metadata-value"></span>
            </div>
            <div class="metadata-row" id="rTagsRow" style="display: none;">
              <span class="metadata-label">Tags</span>
              <div id="rTags" class="metadata-tags"></div>
            </div>
          </div>

          <div class="quick-actions">
            <div id="rLinks" class="action-links"></div>
            <button class="action-btn" id="copyLinkBtn">
              ðŸ“‹ Copy link
            </button>
          </div>
        </aside>

        <!-- Right Column: Accordion Sections -->
        <div class="article-content">
          <div class="accordion-section" data-section="overview">
            <button class="accordion-header" aria-expanded="false">
              <span>Overview</span>
              <span class="accordion-icon">â–¼</span>
            </button>
            <div class="accordion-content" id="rOverview"></div>
          </div>

          <div class="accordion-section" data-section="content">
            <button class="accordion-header" aria-expanded="true">
              <span>Full Content</span>
              <span class="accordion-icon">â–¼</span>
            </button>
            <div class="accordion-content active" id="rBody"></div>
          </div>

          <div class="accordion-section" data-section="attachments" id="rAttachmentsSection" style="display: none;">
            <button class="accordion-header" aria-expanded="false">
              <span>Attachments</span>
              <span class="accordion-icon">â–¼</span>
            </button>
            <div class="accordion-content" id="rAttachments"></div>
          </div>
        </div>
      </div>
    </article>
  </dialog>

  <script>
    async function loadDashboard() {
      const res = await fetch('./data/articles.json');
      const data = await res.json();
      
      // Process dates
      const byDate = {};
      const byCategory = {};
      const byWeek = {};
      
      data.forEach(item => {
        const date = item.date || 'Unknown';
        // Dates are already in YYYY-MM-DD format, use as-is to avoid timezone issues
        if (date !== 'Unknown' && typeof date === 'string') {
          // Validate date format (YYYY-MM-DD)
          const dateMatch = date.match(/^(\d{4})-(\d{2})-(\d{2})/);
          if (dateMatch) {
            byDate[date] = (byDate[date] || 0) + 1;
            
            // Week grouping
            const d = new Date(date + 'T12:00:00'); // Use noon to avoid timezone edge cases
            const weekStart = new Date(d);
            weekStart.setDate(d.getDate() - d.getDay());
            const weekKey = weekStart.toISOString().split('T')[0];
            byWeek[weekKey] = (byWeek[weekKey] || 0) + 1;
          } else {
            // Invalid date format, count as Unknown
            byDate['Unknown'] = (byDate['Unknown'] || 0) + 1;
          }
        } else {
          byDate['Unknown'] = (byDate['Unknown'] || 0) + 1;
        }
        
        const cat = item.subcategory || 'Other';
        byCategory[cat] = (byCategory[cat] || 0) + 1;
      });
      
      // Stats
      document.getElementById('totalCount').textContent = data.length;
      
      // Debug: Check for date issues
      console.log('=== Date Processing Debug ===');
      console.log('Total items:', data.length);
      const allDateKeys = Object.keys(byDate);
      const validDateKeys = allDateKeys.filter(d => d !== 'Unknown');
      console.log('Total keys in byDate:', allDateKeys.length);
      console.log('Valid dates (excluding Unknown):', validDateKeys.length);
      console.log('Sample dates:', validDateKeys.slice(0, 5), '...', validDateKeys.slice(-5));
      console.log('Last 5 date counts:', validDateKeys.slice(-5).map(d => byDate[d]));
      
      // Get unique, sorted dates and ensure no duplicates
      // Object.keys() already returns unique keys, but double-check with Set
      const uniqueDates = [...new Set(validDateKeys)];
      const dates = uniqueDates.sort();
      
      if (validDateKeys.length !== uniqueDates.length) {
        console.warn('âš ï¸ Duplicate dates found in byDate keys:', validDateKeys.length - uniqueDates.length);
        const duplicates = validDateKeys.filter((d, i) => validDateKeys.indexOf(d) !== i);
        console.warn('Duplicate date strings:', duplicates);
      }
      
      console.log('Final dates array length:', dates.length);
      console.log('Last 5 dates in sorted array:', dates.slice(-5));
      console.log('Last 5 counts for sorted dates:', dates.slice(-5).map(d => byDate[d]));
      console.log('=== End Date Processing Debug ===');
      if (dates.length) {
        document.getElementById('dateRange').textContent = `${dates[0]} to ${dates[dates.length-1]}`;
      }
      
      const peakDate = Object.entries(byDate).sort((a,b) => b[1] - a[1])[0];
      if (peakDate) {
        document.getElementById('peakDay').textContent = peakDate[0];
        document.getElementById('peakCount').textContent = `${peakDate[1]} submissions`;
      }
      
      const activeDays = dates.length;
      document.getElementById('avgPerDay').textContent = activeDays ? (data.length / activeDays).toFixed(1) : '-';
      
      // Build Heatmap
      buildHeatmap(byDate, dates);
      
      // Build Timeline
      buildTimeline(byDate, dates);
      
      // Category bars
      buildCategoryBars(byCategory, data.length);
      
      // Week grid
      buildWeekGrid(byWeek);
    }
    
    function buildHeatmap(byDate, dates) {
      if (!dates.length) return;
      
      const heatmap = document.getElementById('heatmap');
      const monthLabels = document.getElementById('monthLabels');
      
      // Clear previous content
      heatmap.innerHTML = '';
      monthLabels.innerHTML = '';
      
      const start = new Date(dates[0]);
      const end = new Date(dates[dates.length - 1]);
      
      // Adjust to start of week
      start.setDate(start.getDate() - start.getDay());
      
      const maxCount = Math.max(...Object.values(byDate));
      const weeks = [];
      const monthPositions = new Map(); // Track month positions
      
      let current = new Date(start);
      let currentWeek = [];
      let weekIndex = 0;
      
      while (current <= end || currentWeek.length > 0) {
        const dateStr = current.toISOString().split('T')[0];
        const count = byDate[dateStr] || 0;
        const level = count === 0 ? 0 : Math.min(4, Math.ceil((count / maxCount) * 4));
        
        // Track month labels (show at start of each month, around day 1-7)
        const monthName = current.toLocaleString('default', { month: 'short' });
        if (current.getDate() <= 7 && !monthPositions.has(monthName)) {
          monthPositions.set(monthName, weekIndex);
        }
        
        currentWeek.push({
          date: dateStr,
          count,
          level,
          day: current.getDay()
        });
        
        if (current.getDay() === 6 || current > end) {
          weeks.push(currentWeek);
          currentWeek = [];
          weekIndex++;
        }
        
        current.setDate(current.getDate() + 1);
        if (current > end && currentWeek.length === 0) break;
      }
      
      // Build heatmap weeks first to calculate widths
      weeks.forEach(week => {
        const weekEl = document.createElement('div');
        weekEl.className = 'heatmap-week';
        
        // Fill in missing days at start
        for (let i = 0; i < week[0].day; i++) {
          const empty = document.createElement('div');
          empty.className = 'heatmap-day';
          empty.style.visibility = 'hidden';
          weekEl.appendChild(empty);
        }
        
        week.forEach(day => {
          const dayEl = document.createElement('div');
          dayEl.className = 'heatmap-day';
          dayEl.dataset.level = day.level;
          dayEl.dataset.tooltip = `${day.date}: ${day.count} posts`;
          dayEl.dataset.date = day.date;
          dayEl.dataset.count = day.count;
          
          // Add tooltip event handlers
          dayEl.addEventListener('mouseenter', (e) => showHeatmapTooltip(e, day.date, day.count));
          dayEl.addEventListener('mouseleave', hideHeatmapTooltip);
          dayEl.addEventListener('mousemove', (e) => updateHeatmapTooltipPosition(e));
          
          weekEl.appendChild(dayEl);
        });
        
        heatmap.appendChild(weekEl);
      });
      
      // Build month labels aligned with week columns
      // Each week column is 24px (cell width) + 4px (gap) = 28px
      const weekColumnWidth = 28;
      const sortedMonths = Array.from(monthPositions.entries()).sort((a, b) => a[1] - b[1]);
      
      // Track which weeks have labels
      let currentWeekIndex = 0;
      sortedMonths.forEach(([monthName, weekIndex]) => {
        // Add spacer divs for weeks before this month's first week
        while (currentWeekIndex < weekIndex) {
          const spacer = document.createElement('div');
          spacer.className = 'month-label-spacer';
          spacer.style.width = `${weekColumnWidth}px`;
          spacer.style.flexShrink = '0';
          monthLabels.appendChild(spacer);
          currentWeekIndex++;
        }
        
        // Calculate how many weeks this month spans (approximate: 4-5 weeks)
        // For simplicity, span across 4 weeks
        const monthSpan = 4;
        const label = document.createElement('div');
        label.className = 'month-label';
        label.textContent = monthName;
        label.style.width = `${weekColumnWidth * monthSpan}px`;
        label.style.flexShrink = '0';
        monthLabels.appendChild(label);
        currentWeekIndex += monthSpan;
      });
    }
    
    // Heatmap tooltip management
    let heatmapTooltip = null;
    
    function showHeatmapTooltip(event, date, count) {
      // Remove existing tooltip if any
      hideHeatmapTooltip();
      
      // Create tooltip element
      heatmapTooltip = document.createElement('div');
      heatmapTooltip.className = 'heatmap-tooltip-portal';
      heatmapTooltip.textContent = `${date}: ${count} ${count === 1 ? 'post' : 'posts'}`;
      document.body.appendChild(heatmapTooltip);
      
      // Force reflow to get accurate dimensions
      heatmapTooltip.offsetHeight;
      
      // Position tooltip
      updateHeatmapTooltipPosition(event);
    }
    
    function updateHeatmapTooltipPosition(event) {
      if (!heatmapTooltip) return;
      
      const cell = event.currentTarget;
      const cellRect = cell.getBoundingClientRect();
      const tooltipRect = heatmapTooltip.getBoundingClientRect();
      
      // If tooltip hasn't rendered yet, use estimated dimensions
      const tooltipHeight = tooltipRect.height || 32;
      const tooltipWidth = tooltipRect.width || 120;
      
      // Calculate position above the cell (centered)
      let top = cellRect.top - tooltipHeight - 8; // 8px gap above cell
      let left = cellRect.left + (cellRect.width / 2) - (tooltipWidth / 2);
      
      // Collision detection: ensure tooltip stays within viewport
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const padding = 10;
      
      // Horizontal collision: keep tooltip within viewport
      if (left < padding) {
        left = padding;
      } else if (left + tooltipWidth > viewportWidth - padding) {
        left = viewportWidth - tooltipWidth - padding;
      }
      
      // Vertical collision: if tooltip would go above viewport, show below cell instead
      if (top < padding) {
        top = cellRect.bottom + 8; // Show below cell
      }
      
      // Ensure tooltip doesn't go below viewport
      if (top + tooltipHeight > viewportHeight - padding) {
        top = viewportHeight - tooltipHeight - padding;
      }
      
      heatmapTooltip.style.top = `${top}px`;
      heatmapTooltip.style.left = `${left}px`;
    }
    
    function hideHeatmapTooltip() {
      if (heatmapTooltip) {
        heatmapTooltip.remove();
        heatmapTooltip = null;
      }
    }
    
    function buildTimeline(byDate, dates) {
      const chart = document.getElementById('timelineChart');
      const labelsContainer = document.getElementById('timelineLabels');
      const scrollEl = document.getElementById('dailyChartScroll');
      const innerEl = document.getElementById('dailyChartInner');
      
      // Clear previous content
      chart.innerHTML = '';
      if (labelsContainer) labelsContainer.innerHTML = '';
      
      // Debug: Check for duplicates and verify data
      console.log('=== Timeline Debug ===');
      console.log('Total dates:', dates.length);
      console.log('Last 5 dates:', dates.slice(-5));
      console.log('Last 5 counts:', dates.slice(-5).map(d => byDate[d]));
      
      // Check for duplicates
      const uniqueDates = [...new Set(dates)];
      if (uniqueDates.length !== dates.length) {
        console.warn('Duplicate dates found!', dates.length - uniqueDates.length, 'duplicates');
        const duplicates = dates.filter((d, i) => dates.indexOf(d) !== i);
        console.warn('Duplicate dates:', duplicates);
      }
      
      // Filter out any invalid dates and ensure we only use dates that exist in byDate
      const validDates = dates.filter(date => {
        const exists = date in byDate;
        if (!exists) {
          console.warn('Date in array but not in byDate:', date);
        }
        return exists && date !== 'Unknown';
      });
      
      console.log('Valid dates after filtering:', validDates.length);
      console.log('Last 5 valid dates:', validDates.slice(-5));
      console.log('Last 5 valid counts:', validDates.slice(-5).map(d => byDate[d]));
      
      if (validDates.length === 0) {
        console.warn('No valid dates for timeline');
        return;
      }
      
      // Calculate maxCount only from valid dates (exclude 'Unknown' and any invalid entries)
      const counts = validDates.map(d => byDate[d]).filter(c => c != null && !isNaN(c));
      if (counts.length === 0) {
        console.warn('No valid counts for timeline');
        return;
      }
      const maxCount = Math.max(...counts);
      console.log('Max count:', maxCount);
      console.log('Counts array length:', counts.length, 'Valid dates length:', validDates.length);

      // --- Shared layout (bars + timeline) ---
      const total = validDates.length;
      const barGap = 6;
      const minBarWidth = 14;   // if below this, we allow horizontal scroll instead of squishing more
      const maxBarWidth = 80;   // prevents absurdly wide bars when there are few days
      // Get available width from scroll container or chart's parent, accounting for padding
      const scrollContainer = scrollEl || chart.closest('.daily-chart-scroll');
      const available = scrollContainer?.clientWidth || chart.parentElement?.clientWidth || 900;
      let barWidth = Math.floor((available - barGap * (total - 1)) / total);
      barWidth = Math.min(maxBarWidth, Math.max(minBarWidth, barWidth));
      // Calculate exact inner width: total bars + gaps between them (no trailing gap)
      // This ensures the last bar ends exactly at innerWidth with no extra blank space
      const innerWidth = total * barWidth + (total - 1) * barGap;

      // Set widths: bars container is exact, labels container adds padding for edge labels
      if (innerEl) innerEl.style.width = `${innerWidth}px`;
      chart.style.width = `${innerWidth}px`;
      chart.style.gap = `${barGap}px`;
      // Labels container width matches bars, but CSS padding prevents clipping
      if (labelsContainer) {
        labelsContainer.style.width = `${innerWidth}px`;
      }
      
      // Build bars only for valid dates
      validDates.forEach((date, i) => {
        const count = byDate[date];
        if (count === undefined || count === null) {
          console.warn('Missing count for date:', date);
          return;
        }
        
        const height = (count / maxCount) * 240;
        
        const bar = document.createElement('div');
        bar.className = 'timeline-bar';
        bar.style.height = `${height}px`;
        bar.style.width = `${barWidth}px`;
        bar.style.flex = `0 0 ${barWidth}px`;
        bar.dataset.tooltip = `${date}: ${count} posts`;
        bar.dataset.date = date;
        bar.dataset.count = count;
        
        // Add tooltip event handlers
        bar.addEventListener('mouseenter', (e) => showTimelineTooltip(e, date, count));
        bar.addEventListener('mouseleave', hideTimelineTooltip);
        bar.addEventListener('mousemove', (e) => updateTimelineTooltipPosition(e));
        
        chart.appendChild(bar);
      });

      // Build timeline labels aligned with bars (sparse ticks centered under bars)
      if (labelsContainer) {
        const targetTicks = window.innerWidth <= 768 ? 6 : 10;
        const buildTickIndices = (n, desired) => {
          if (n <= desired) return Array.from({length:n}, (_,i)=>i);
          const ticks = [];
          for (let t = 0; t < desired; t++) {
            const idx = Math.round(t * (n - 1) / (desired - 1));
            ticks.push(idx);
          }
          return Array.from(new Set(ticks));
        };
        // Format using the raw date string parts to avoid timezone shifts
        const formatDate = (s) => {
          const base = String(s || '').split('T')[0];
          const [yy, mm, dd] = base.split('-');
          if (!mm || !dd) return s;
          return `${mm.padStart(2,'0')}/${dd.padStart(2,'0')}`;
        };

        const renderTicks = (desired) => {
          labelsContainer.innerHTML = '';
          const indices = buildTickIndices(total, desired);
          indices.forEach((i) => {
            const tick = document.createElement('span');
            tick.className = 'tick';
            tick.textContent = formatDate(validDates[i]);
            const x = i * (barWidth + barGap) + (barWidth / 2);
            // Clamp so tick text doesn't extend scrollable width
            const clampedX = Math.min(innerWidth - 1, Math.max(1, x));
            tick.style.left = `${clampedX}px`;
            labelsContainer.appendChild(tick);
          });
        };

        renderTicks(targetTicks);

        // Extra safety: if ticks overlap, reduce tick count and rerender
        requestAnimationFrame(() => {
          const ticks = Array.from(labelsContainer.querySelectorAll('.tick'));
          let overlap = false;
          for (let i = 1; i < ticks.length; i++) {
            const a = ticks[i - 1].getBoundingClientRect();
            const b = ticks[i].getBoundingClientRect();
            if (a.right > b.left) { overlap = true; break; }
          }
          if (overlap) {
            renderTicks(Math.max(3, targetTicks - 2));
          }
        });
      }
      
      // Verify bars created
      const barCount = chart.children.length;
      console.log('Bars created:', barCount);
      console.log('=== End Timeline Debug ===');

      // Initialize slider/scroll sync (mobile) after render
      initTimelineScrollSync();

      // Re-render layout on resize (keeps bars + timeline locked together)
      window.__dailyTimelineLast = { byDate, dates };
      if (!window.__dailyTimelineResizeWired) {
        window.__dailyTimelineResizeWired = true;
        let t;
        window.addEventListener('resize', () => {
          clearTimeout(t);
          t = setTimeout(() => {
            const last = window.__dailyTimelineLast;
            if (last) buildTimeline(last.byDate, last.dates);
          }, 150);
        });
      }
    }
    
    // Timeline tooltip management
    let timelineTooltip = null;
    
    function showTimelineTooltip(event, date, count) {
      // Remove existing tooltip if any
      hideTimelineTooltip();
      
      // Create tooltip element
      timelineTooltip = document.createElement('div');
      timelineTooltip.className = 'timeline-tooltip-portal';
      timelineTooltip.textContent = `${date}: ${count} posts`;
      document.body.appendChild(timelineTooltip);
      
      // Force reflow to get accurate dimensions
      timelineTooltip.offsetHeight;
      
      // Position tooltip
      updateTimelineTooltipPosition(event);
    }
    
    function updateTimelineTooltipPosition(event) {
      if (!timelineTooltip) return;
      
      const bar = event.currentTarget;
      const barRect = bar.getBoundingClientRect();
      const tooltipRect = timelineTooltip.getBoundingClientRect();
      
      // If tooltip hasn't rendered yet, use estimated dimensions
      const tooltipHeight = tooltipRect.height || 32;
      const tooltipWidth = tooltipRect.width || 120;
      
      // Calculate position above the bar (centered)
      let top = barRect.top - tooltipHeight - 8; // 8px gap above bar
      let left = barRect.left + (barRect.width / 2) - (tooltipWidth / 2);
      
      // Collision detection: ensure tooltip stays within viewport
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const padding = 10;
      
      // Horizontal collision: keep tooltip within viewport
      if (left < padding) {
        left = padding;
      } else if (left + tooltipWidth > viewportWidth - padding) {
        left = viewportWidth - tooltipWidth - padding;
      }
      
      // Vertical collision: if tooltip would go above viewport, show below bar instead
      if (top < padding) {
        top = barRect.bottom + 8; // Show below bar
      }
      
      // Ensure tooltip doesn't go below viewport
      if (top + tooltipHeight > viewportHeight - padding) {
        top = viewportHeight - tooltipHeight - padding;
      }
      
      timelineTooltip.style.top = `${top}px`;
      timelineTooltip.style.left = `${left}px`;
    }
    
    function hideTimelineTooltip() {
      if (timelineTooltip) {
        timelineTooltip.remove();
        timelineTooltip = null;
      }
    }

    // Sync horizontal scroll with slider for the Daily Post Volume chart
    function initTimelineScrollSync() {
      const scrollEl = document.getElementById('dailyChartScroll');
      const sliderEl = document.getElementById('dailyChartSlider');
      if (!scrollEl || !sliderEl) return;

      const getMaxScroll = () => Math.max(0, scrollEl.scrollWidth - scrollEl.clientWidth);

      const syncSliderFromScroll = () => {
        const maxScroll = getMaxScroll();
        const value = maxScroll <= 0 ? 0 : Math.round((scrollEl.scrollLeft / maxScroll) * 100);
        sliderEl.value = String(value);
      };

      const syncScrollFromSlider = () => {
        const maxScroll = getMaxScroll();
        scrollEl.scrollLeft = (Number(sliderEl.value) / 100) * maxScroll;
      };

      // Remove then add to avoid duplicates after re-render
      scrollEl.removeEventListener('scroll', syncSliderFromScroll);
      sliderEl.removeEventListener('input', syncScrollFromSlider);

      scrollEl.addEventListener('scroll', syncSliderFromScroll, { passive: true });
      sliderEl.addEventListener('input', syncScrollFromSlider);

      // Initialize position
      setTimeout(() => {
        // Clamp (width might have changed since last render)
        scrollEl.scrollLeft = Math.min(scrollEl.scrollLeft, getMaxScroll());
        syncSliderFromScroll();
      }, 0);
      window.addEventListener('resize', syncSliderFromScroll);
    }
    
    function buildCategoryBars(byCategory, total) {
      const container = document.getElementById('categoryBars');
      const sorted = Object.entries(byCategory).sort((a,b) => b[1] - a[1]);
      const maxCount = sorted[0]?.[1] || 1;
      
      sorted.forEach(([cat, count]) => {
        const width = (count / maxCount) * 100;
        const row = document.createElement('div');
        row.className = 'category-row';
        row.innerHTML = `
          <span class="label">${cat}</span>
          <div class="bar-wrapper">
            <div class="bar" style="width: ${width}%">${count}</div>
          </div>
        `;
        container.appendChild(row);
      });
    }
    
    function buildWeekGrid(byWeek) {
      const container = document.getElementById('weekGrid');
      const sorted = Object.entries(byWeek).sort((a,b) => b[0].localeCompare(a[0]));
      const maxCount = Math.max(...Object.values(byWeek));
      
      sorted.slice(0, 8).forEach(([week, count]) => {
        const width = (count / maxCount) * 100;
        const card = document.createElement('div');
        card.className = 'week-card';
        card.innerHTML = `
          <h4>
            Week of ${week}
            <span class="count">${count}</span>
          </h4>
          <div class="bar-container">
            <div class="bar-fill" style="width: ${width}%"></div>
          </div>
        `;
        container.appendChild(card);
      });
    }
    
    // Tab navigation
    function initTabs() {
      const tabItems = document.querySelectorAll('.tab-item');
      const views = document.querySelectorAll('.dashboard-view');
      
      function switchView(viewName) {
        // Update tab active states
        tabItems.forEach(tab => {
          if (tab.dataset.view === viewName) {
            tab.classList.add('active');
          } else {
            tab.classList.remove('active');
          }
        });
        
        // Hide all views first to prevent layout shifts
        views.forEach(v => {
          v.style.display = 'none';
          v.classList.remove('active');
        });
        
        // Then show the target view with fade transition
        const targetView = document.getElementById(`view-${viewName}`);
        if (targetView) {
          targetView.style.display = 'block';
          targetView.style.opacity = '0';
          targetView.classList.add('active');
          // Trigger reflow
          targetView.offsetHeight;
          requestAnimationFrame(() => {
            targetView.style.opacity = '1';
          });
        }
      }
      
      // Tab click handlers
      tabItems.forEach(item => {
        item.addEventListener('click', () => {
          switchView(item.dataset.view);
        });
      });
      
    }
    
    // Load dashboard when page loads
      if (document.getElementById('dashboard-section')) {
        loadDashboard();
        initTabs();
      }
  </script>
</body>
</html>


